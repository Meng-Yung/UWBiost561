[{"path":"https://meng-yung.github.io/UWBiost561/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 UWBiost561 authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/articles/UWBiost561.html","id":"generating-a-graph","dir":"Articles","previous_headings":"","what":"Generating a graph","title":"UWBiost561","text":"following lines code runs generate_partial_clique() function n = 10, clique_fraction = 0.5, clique_edge_density = 0.9. detailed documentation, please visit reference page.","code":"library(UWBiost561) set.seed(0) simulation <- UWBiost561::generate_partial_clique(   n = 10,   clique_fraction = 0.5,   clique_edge_density = 0.9 ) adj_mat <- simulation$adj_mat adj_mat ##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ##  [1,]    1    0    0    0    1    0    1    0    1     1 ##  [2,]    0    1    0    0    0    0    0    0    0     0 ##  [3,]    0    0    1    0    0    0    0    0    0     0 ##  [4,]    0    0    0    1    1    0    0    0    0     0 ##  [5,]    1    0    0    1    1    0    0    1    1     1 ##  [6,]    0    0    0    0    0    1    0    0    0     0 ##  [7,]    1    0    0    0    0    0    1    0    0     0 ##  [8,]    0    0    0    0    1    0    0    1    1     1 ##  [9,]    1    0    0    0    1    0    0    1    1     1 ## [10,]    1    0    0    0    1    0    0    1    1     1"},{"path":"https://meng-yung.github.io/UWBiost561/articles/UWBiost561.html","id":"calculating-partial-clique","dir":"Articles","previous_headings":"","what":"Calculating partial Clique","title":"UWBiost561","text":"Now generated graph, can compute maximal partial cliques via one also various implementations within package. following lines code use default implementation compute_maximal_partial_clique(), created author directly.","code":"set.seed(10) res <- UWBiost561::compute_maximal_partial_clique(   adj_mat = adj_mat,   alpha = 0.9 ) res ## $clique_idx ## [1]  1  5  8  9 10 ##  ## $edge_density ## [1] 0.9"},{"path":"https://meng-yung.github.io/UWBiost561/articles/UWBiost561.html","id":"using-different-implementations-for-calculating-partial-clique","dir":"Articles","previous_headings":"","what":"Using different implementations for calculating partial Clique","title":"UWBiost561","text":"also many implements compute_maximal_partial_clique() within package, can called directly via compute_maximal_partial_clique1() compute_maximal_partial_clique15(), call compute_maximal_partial_clique_master() setting number parameter desired implementation. number 10 implementation, act exactly default compute_maximal_partial_clique(). demonstrate example master function useful next section. Note: warned implementations , might return correct maximal partial clique, others might fail together.","code":"set.seed(10) result <- UWBiost561::compute_maximal_partial_clique_master(   adj_mat = adj_mat,    alpha = 0.95,    number = 11,    time_limit = 30 ) result ## $clique_idx ## [1]  1  5  9 10 ##  ## $edge_density ## [1] 1 ##  ## $status ## [1] \"completed\" ##  ## $valid ## [1] TRUE"},{"path":"https://meng-yung.github.io/UWBiost561/articles/UWBiost561.html","id":"small-example-simulation-testing","dir":"Articles","previous_headings":"","what":"Small example simulation testing","title":"UWBiost561","text":"Now, following code provide small foundation simulation testing implementations compute_maximal_partial_clique() via help master function. light demo iterates different values n, also implement error handling just case implementations fails. Since demo, ran 1 trial 1 n, thus take much time complete. aware larger n, run time start increase exponentially, please carefully plan simulation study make sure fits within computational resources acess .","code":"rm(list=ls()) set.seed(10) library(UWBiost561)  imp_numbers <- 1:15 trials <- 1 n_numbers <- 6  # Generate the simulation level_trial_list <- lapply(1:trials, function(trial){   print(paste(\"Working on Trial:\", trial))   set.seed(trial)  # Freeze randomness for this trial    # Loop over the different implementations (imp_numbers)   trial_result_list <- lapply(imp_numbers, function(imp_number){     print(paste(\"Working on Implementation:\", imp_number))      # Loop over n values from 5 to 10 for each implementation     result_n_list <- lapply(n_numbers, function(n){       set.seed(trial)  # To freeze the randomness of adj_mat generation       print(paste(\"Generating with n =\", n))        # Generate the adjacency matrix with varying n (5 to 10)       data <- UWBiost561::generate_partial_clique(n = n,                                                   clique_fraction = 0.5,                                                   clique_edge_density = 0.95)       adj_mat <- data$adj_mat        # Compute the maximal partial clique for this n and imp_number       result <- tryCatch({         # Attempt to run the function         UWBiost561::compute_maximal_partial_clique_master(           adj_mat = adj_mat,           alpha = 0.95,           number = imp_number,           time_limit = 30         )       }, error = function(e) {         # Handle the error: 'e' will contain the error message         cat(\"An error occurred:\", e$message, \"\\n\")         return(NULL)  # Return NULL       })        return(result)     })      names(result_n_list) <- paste(\"n =\", 10)     return(result_n_list)   })    names(trial_result_list) <- paste(\"Implementation:\", imp_numbers)   return(trial_result_list) }) ## [1] \"Working on Trial: 1\" ## [1] \"Working on Implementation: 1\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 2\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 3\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 4\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 5\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 6\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 7\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 8\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 9\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 10\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 11\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 12\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 13\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 14\" ## [1] \"Generating with n = 6\" ## [1] \"Working on Implementation: 15\" ## [1] \"Generating with n = 6\" names(level_trial_list) <- paste(\"Trial:\", 1:trials)  level_trial_list ## $`Trial: 1` ## $`Trial: 1`$`Implementation: 1` ## $`Trial: 1`$`Implementation: 1`$`n = 10` ## $`Trial: 1`$`Implementation: 1`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 1`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 1`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 1`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 2` ## $`Trial: 1`$`Implementation: 2`$`n = 10` ## $`Trial: 1`$`Implementation: 2`$`n = 10`$clique_idx ## [1] 3 5 ##  ## $`Trial: 1`$`Implementation: 2`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 2`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 2`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 3` ## $`Trial: 1`$`Implementation: 3`$`n = 10` ## $`Trial: 1`$`Implementation: 3`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 3`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 3`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 3`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 4` ## $`Trial: 1`$`Implementation: 4`$`n = 10` ## $`Trial: 1`$`Implementation: 4`$`n = 10`$clique_idx ## [1] 3 1 4 ##  ## $`Trial: 1`$`Implementation: 4`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 4`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 4`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 5` ## $`Trial: 1`$`Implementation: 5`$`n = 10` ## $`Trial: 1`$`Implementation: 5`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 5`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 5`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 5`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 6` ## $`Trial: 1`$`Implementation: 6`$`n = 10` ## $`Trial: 1`$`Implementation: 6`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 6`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 6`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 6`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 7` ## $`Trial: 1`$`Implementation: 7`$`n = 10` ## $`Trial: 1`$`Implementation: 7`$`n = 10`$clique_idx ## [1] 3 4 5 ##  ## $`Trial: 1`$`Implementation: 7`$`n = 10`$edge_density ## [1] 0.5 ##  ## $`Trial: 1`$`Implementation: 7`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 7`$`n = 10`$valid ## [1] FALSE ##  ##  ##  ## $`Trial: 1`$`Implementation: 8` ## $`Trial: 1`$`Implementation: 8`$`n = 10` ## $`Trial: 1`$`Implementation: 8`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 8`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 8`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 8`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 9` ## $`Trial: 1`$`Implementation: 9`$`n = 10` ## $`Trial: 1`$`Implementation: 9`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 9`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 9`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 9`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 10` ## $`Trial: 1`$`Implementation: 10`$`n = 10` ## $`Trial: 1`$`Implementation: 10`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 10`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 10`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 10`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 11` ## $`Trial: 1`$`Implementation: 11`$`n = 10` ## $`Trial: 1`$`Implementation: 11`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 11`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 11`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 11`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 12` ## $`Trial: 1`$`Implementation: 12`$`n = 10` ## $`Trial: 1`$`Implementation: 12`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 12`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 12`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 12`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 13` ## $`Trial: 1`$`Implementation: 13`$`n = 10` ## $`Trial: 1`$`Implementation: 13`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 13`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 13`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 13`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 14` ## $`Trial: 1`$`Implementation: 14`$`n = 10` ## $`Trial: 1`$`Implementation: 14`$`n = 10`$clique_idx ## [1] 1 3 4 ##  ## $`Trial: 1`$`Implementation: 14`$`n = 10`$edge_density ## [1] 1 ##  ## $`Trial: 1`$`Implementation: 14`$`n = 10`$status ## [1] \"completed\" ##  ## $`Trial: 1`$`Implementation: 14`$`n = 10`$valid ## [1] TRUE ##  ##  ##  ## $`Trial: 1`$`Implementation: 15` ## $`Trial: 1`$`Implementation: 15`$`n = 10` ## $`Trial: 1`$`Implementation: 15`$`n = 10`$clique_idx ## [1] NA ##  ## $`Trial: 1`$`Implementation: 15`$`n = 10`$edge_density ## [1] NA ##  ## $`Trial: 1`$`Implementation: 15`$`n = 10`$status ## [1] \"timed_out\" ##  ## $`Trial: 1`$`Implementation: 15`$`n = 10`$valid ## [1] FALSE"},{"path":"https://meng-yung.github.io/UWBiost561/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michael Yung. Author, maintainer.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Yung M (2025). UWBiost561: Package includes exercise practice course learning. R package version 0.0.0.9000, https://meng-yung.github.io/UWBiost561/.","code":"@Manual{,   title = {UWBiost561: Package that includes exercise and practice for course learning},   author = {Michael Yung},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://meng-yung.github.io/UWBiost561/}, }"},{"path":"https://meng-yung.github.io/UWBiost561/index.html","id":"purpose","dir":"","previous_headings":"","what":"Package that includes exercise and practice for course learning","title":"Package that includes exercise and practice for course learning","text":"package UW BIOST 561 (Spring 2025), taught Kevin Lin. package includes functions designed generate partial cliques determine partial clique size. URL GitHub (.e., source code) : https://github.com/Meng-Yung/UWBiost561 URL Pkgdown webpage : https://meng-yung.github.io/UWBiost561/","code":""},{"path":"https://meng-yung.github.io/UWBiost561/index.html","id":"how-to-install","dir":"","previous_headings":"","what":"How to install","title":"Package that includes exercise and practice for course learning","text":"package called UWBiost561. install, run following code (R): Upon completion, can run following code (R):","code":"library(devtools) devtools::install_github(\"Meng-Yung/UWBiost561\") library(UWBiost561)"},{"path":"https://meng-yung.github.io/UWBiost561/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Package that includes exercise and practice for course learning","text":"package suggests following packages: “knitr”, “rmarkdown”, “bookdown”, “tidyverse”, “ggplot2”, “testthat”.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/index.html","id":"session-info","dir":"","previous_headings":"","what":"Session info","title":"Package that includes exercise and practice for course learning","text":"package developed following environment","code":"> devtools::session_info() ─ Session info ──────────────────────────  setting  value  version  R version 4.5.0 (2025-04-11 ucrt)  os       Windows 11 x64 (build 26100)  system   x86_64, mingw32  ui       RStudio  language (EN)  collate  English_United States.utf8  ctype    English_United States.utf8  tz       America/Los_Angeles  date     2025-05-30  rstudio  2025.05.0+496 Mariposa Orchid (desktop)  pandoc   3.4 @ D:/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)  quarto   ERROR: Unknown command \"TMPDIR=C:/Users/Michael/AppData/Local/Temp/RtmpcliMgZ/file1edc3b3259fd\". Did you mean command \"create\"? @ D:\\\\RStudio\\\\resources\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe  ─ Packages ──────────────────────────────  package     * version date (UTC) lib source  bookdown      0.43    2025-04-15 [1] CRAN (R 4.5.0)  cachem        1.1.0   2024-05-16 [1] CRAN (R 4.5.0)  callr         3.7.6   2024-03-25 [1] CRAN (R 4.5.0)  cli           3.6.5   2025-04-23 [1] CRAN (R 4.5.0)  desc          1.4.3   2023-12-10 [1] CRAN (R 4.5.0)  devtools      2.4.5   2022-10-11 [1] CRAN (R 4.5.0)  digest        0.6.37  2024-08-19 [1] CRAN (R 4.5.0)  ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.5.0)  evaluate      1.0.3   2025-01-10 [1] CRAN (R 4.5.0)  fastmap       1.2.0   2024-05-15 [1] CRAN (R 4.5.0)  fs            1.6.6   2025-04-12 [1] CRAN (R 4.5.0)  glue          1.8.0   2024-09-30 [1] CRAN (R 4.5.0)  htmltools     0.5.8.1 2024-04-04 [1] CRAN (R 4.5.0)  htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.5.0)  httpuv        1.6.16  2025-04-16 [1] CRAN (R 4.5.0)  knitr         1.50    2025-03-16 [1] CRAN (R 4.5.0)  later         1.4.2   2025-04-08 [1] CRAN (R 4.5.0)  lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.5.0)  magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.5.0)  memoise       2.0.1   2021-11-26 [1] CRAN (R 4.5.0)  mime          0.13    2025-03-17 [1] CRAN (R 4.5.0)  miniUI        0.1.2   2025-04-17 [1] CRAN (R 4.5.0)  pillar        1.10.2  2025-04-05 [1] CRAN (R 4.5.0)  pkgbuild      1.4.8   2025-05-26 [1] CRAN (R 4.5.0)  pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.5.0)  pkgdown       2.1.3   2025-05-25 [1] CRAN (R 4.5.0)  pkgload       1.4.0   2024-06-28 [1] CRAN (R 4.5.0)  processx      3.8.6   2025-02-21 [1] CRAN (R 4.5.0)  profvis       0.4.0   2024-09-20 [1] CRAN (R 4.5.0)  promises      1.3.2   2024-11-28 [1] CRAN (R 4.5.0)  ps            1.9.1   2025-04-12 [1] CRAN (R 4.5.0)  purrr         1.0.4   2025-02-05 [1] CRAN (R 4.5.0)  R6            2.6.1   2025-02-15 [1] CRAN (R 4.5.0)  Rcpp          1.0.14  2025-01-12 [1] CRAN (R 4.5.0)  remotes       2.5.0   2024-03-17 [1] CRAN (R 4.5.0)  rlang         1.1.6   2025-04-11 [1] CRAN (R 4.5.0)  rmarkdown     2.29    2024-11-04 [1] CRAN (R 4.5.0)  rstudioapi    0.17.1  2024-10-22 [1] CRAN (R 4.5.0)  sessioninfo   1.2.3   2025-02-05 [1] CRAN (R 4.5.0)  shiny         1.10.0  2024-12-14 [1] CRAN (R 4.5.0)  tibble        3.2.1   2023-03-20 [1] CRAN (R 4.5.0)  urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.5.0)  usethis       3.1.0   2024-11-26 [1] CRAN (R 4.5.0)  vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.5.0)  withr         3.0.2   2024-10-28 [1] CRAN (R 4.5.0)  xfun          0.52    2025-04-02 [1] CRAN (R 4.5.0)  xtable        1.8-4   2019-04-21 [1] CRAN (R 4.5.0)  yaml          2.3.10  2024-07-26 [1] CRAN (R 4.5.0)   [1] D:/R-4.5.0/library"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_correct_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the correct density, given a set of nodes — compute_correct_density","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"define clique_idx length 1 density 1.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_correct_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"","code":"compute_correct_density(adj_mat, clique_idx)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_correct_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"adj_mat symmetric matrix values 0 1, 1's along diagonal, row- column-names, 5 50  rows/columns (inclusive). clique_idx numeric vector index numbers corresponding nodes (.e., values 1 nrow(adj_mat)) function deems maximum partial clique. vector duplicate elements, must positive integers, largest value exceed nrow(adj_mat)","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_correct_density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"numeric, density edges among adj_mat[clique_idx,clique_idx]","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique","text":"Given adjacency matrix edge density threshold alpha, function computes maximal partial clique — subset nodes whose induced subgraph edge density least alpha.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique","text":"","code":"compute_maximal_partial_clique(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique","text":"adj_mat symmetric binary (0/1) matrix 1s diagonal, row/column names. Must 5 50 rows/columns. alpha single numeric value 0.5 1 (inclusive) specifying minimum required edge density.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique","text":"list following elements: clique_idx, numeric vector node indices forming maximal partial clique. edge_density, edge density (0 1) returned clique.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique","text":"","code":"adj <- matrix(1, nrow = 6, ncol = 6) adj[1, 2] <- adj[2, 1] <- 0 diag(adj) <- 1 result <- compute_maximal_partial_clique(adj, 0.9) print(result) #> $clique_idx #> [1] 1 2 3 4 5 6 #>  #> $edge_density #> [1] 0.9333333 #>"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"Compute Maximal Partial Clique","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"","code":"compute_maximal_partial_clique1(adj_mat, alpha, verbose = FALSE)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"adj_mat symmetric 0/1 adjacency matrix 1s diagonal. alpha numeric threshold 0.5 1 indicating required edge density. verbose Logical; whether print debug output. Default FALSE.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"list : clique_idx Vector node indices maximal partial clique. edge_density Density subgraph induced clique_idx.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"Given adjacency matrix edge density threshold alpha, function computes maximal partial clique — subset nodes whose induced subgraph edge density least alpha.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"","code":"compute_maximal_partial_clique10(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"adj_mat symmetric binary (0/1) matrix 1s diagonal, row/column names. Must 5 50 rows/columns. alpha single numeric value 0.5 1 (inclusive) specifying minimum required edge density.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"list following elements: clique_idx, numeric vector node indices forming maximal partial clique. edge_density, edge density (0 1) returned clique.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"","code":"adj <- matrix(1, nrow = 6, ncol = 6) adj[1, 2] <- adj[2, 1] <- 0 diag(adj) <- 1 result <- compute_maximal_partial_clique10(adj, 0.9) print(result) #> $clique_idx #> [1] 1 2 3 4 5 6 #>  #> $edge_density #> [1] 0.9333333 #>"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique11","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"Determines indices corresponding maximal partial clique adjacency matrix given partial clique density.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"","code":"compute_maximal_partial_clique11(adj_mat, alpha, method = c(\"simple\", \"pivot\"))"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"adj_mat symmetric adjacency matrix 5-50 rows columns. alpha numeric value 0.5 1 (inclusive) indicating minimum fraction edges among nodes outputted partial clique. method One \"simple\" \"pivot\". \"simple\" searches maximal partial clique using modified version original Bron-Kerbosch algorithm, \"pivot\" uses modified version Bron-Kerbosch algorith pivot (Bron & Kerbosch 1973).","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"Outputs list containing clique_idx: vector indices form partial clique edge_density: Percentage edges adj_mat among nodes clique_idx.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"function uses modified versions Bron-Kerbosch algorithm, designed compute maximal full cliques, compute maximal partial cliques, allowing users specify \"simple\" \"pivot\" (Bron & Kerbosch 1973). Specifically, alpha < 1, algorithm modified candidate excluded nodes iteration restricted neighbors. Rather, candidate clique initially reported maximal clique satisfies density alpha/2 (help find cliques two nodes alone satisfy alpha density, together clique ), searches final results choose largest clique satisfies alpha. alpha = 1 set, Bron-Kerbosch algorithm applied directly. Using","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"Bron, C., & Kerbosch, J. (1973). Algorithm 457: finding cliques undirected graph. Communications ACM, 16(9), 575-577.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":null,"dir":"Reference","previous_headings":"","what":"find maximal partial clique — compute_maximal_partial_clique12","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"find maximal partial clique","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"","code":"compute_maximal_partial_clique12(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"adj_mat matrix look maximal partial clique alpha density partial clique needs reach","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"returns list two things, nodes maximal partial clique, density","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique13","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"Compute maximal partial clique","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"","code":"compute_maximal_partial_clique13(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"adj_mat adj_mat Numeric matrix (n_n) 0/1's, symmetric, 1's diagonal, row/col names, 5:50. alpha Single numeric 0.5 1, minimum required edge-density.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"list clique_idx edge_density","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique function — compute_maximal_partial_clique14","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"function identifies subset nodes binary symmetric adjacency matrix form maximal partial clique edge density least alpha. uses greedy expansion algorithm starting top-k highest-degree nodes iteratively adds nodes maintaining required edge density. However, guarantee best solution every task, limited top-k, especially top-k large matrix size large.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"","code":"compute_maximal_partial_clique14(adj_mat, alpha, top_k_seeds = NULL)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"adj_mat nxn undirected graph 1 meaning connected 0 meaning unconnected. symmetric generated generate_partial_clique_function. n 5 50 inclusive. alpha threshold minimum edge density potential clique. range 0.5 1 inclusive. top_k_seeds value make algorithm efficient setting starter nodes connections. set sqrt number nodes matrix.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"list two elements: clique_idx numeric vector node indices partial clique. edge_density edge density among nodes.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":null,"dir":"Reference","previous_headings":"","what":"Find hte matximal partial clique — compute_maximal_partial_clique15","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"Start first entry, iteratively add nodes. first moment find valid click, stop","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"","code":"compute_maximal_partial_clique15(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"adj_mat graph alpha minimum threshold stop","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"list","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute partial clique — compute_maximal_partial_clique2","title":"Compute partial clique — compute_maximal_partial_clique2","text":"Randomly try bunch cliques return largest one passes threshold","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute partial clique — compute_maximal_partial_clique2","text":"","code":"compute_maximal_partial_clique2(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute partial clique — compute_maximal_partial_clique2","text":"adj_mat adjacency matrix 0,1 alpha minimum edge density","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute partial clique — compute_maximal_partial_clique2","text":"list containing maximum partial clique density","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximum partial clique. — compute_maximal_partial_clique3","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"Compute maximum partial clique.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"","code":"compute_maximal_partial_clique3(adj_mat, alpha, verbose = 0)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"adj_mat Matrix. Adjacency matrix search. alpha Numeric. Minimum edge density potential partial clique. verbose boolean","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"List. clique_idx Nodes found maximum partial clique. edge_density Edge density found clique. alpha.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"function computes approximate maximal partial clique given adjacency matrix, edge density among selected nodes least alpha.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"","code":"compute_maximal_partial_clique4(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"adj_mat symmetric adjacency matrix (0/1) diagonal 1s. alpha numeric value 0.5 1, representing minimum edge density required.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"list following elements: clique_idx numeric vector node indices form partial clique. edge_density edge density among selected nodes (0 1).","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"function attempts find largest subset nodes binary adjacency matrix induced subgraph edge density least alpha. approach uses greedy heuristic: node graph, iteratively adds neighboring nodes increase edge density additions satisfy required threshold. method guarantee global optimum, returns reasonably large dense partial clique within practical time frame.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"","code":"compute_maximal_partial_clique5(adj_mat, alpha, verbose = FALSE)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"adj_mat symmetric binary adjacency matrix 1s diagonal row/col names. alpha numeric scalar 0.5 1. Minimum required edge density. verbose Logical; TRUE, prints progress. Default FALSE.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"list : clique_idx Numeric vector node indices forming partial clique. edge_density actual edge density among nodes.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"final result includes indices selected nodes achieved edge density.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique6","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"function finds reasonably large set nodes graph (represented adjacency matrix) forms partial clique edge density least alpha. uses greedy approach expand highly connected nodes.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"","code":"compute_maximal_partial_clique6(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"adj_mat symmetric binary adjacency matrix diagonal 1s row/column names. alpha numeric value 0.5 1. minimum density required clique.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"list two elements: clique_idx Indices nodes maximal partial clique. edge_density edge density among selected nodes.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"Find maximal partial clique adjacency matrix","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"","code":"compute_maximal_partial_clique7(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"adj_mat symmetric matrix 5 50 rows alpha numeric value 0.5 1","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"list containing clique_idx edge density","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"Compute maximal partial clique function computes maximal partial clique recursively removing node least number edges desired density (alpha) obtained","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"","code":"compute_maximal_partial_clique8(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"adj_mat adjacency matrix edges node . contain least 5 nodes 50. alpha density required partial clique, excluding self-edges.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"list containing index clique clique_idx density clique","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the maximal partial clique — compute_maximal_partial_clique9","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"function finds subset nodes forming partial clique given adjacency matrix edge density among nodes least alpha.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"","code":"compute_maximal_partial_clique9(adj_mat, alpha)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"adj_mat symmetric 0/1 adjacency matrix diagonal values 1, row/column names, size 5 50. alpha single numeric value 0.5 1, specifying required minimum edge density.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"list two elements: clique_idx numeric vector node indices forming identified partial clique. edge_density actual edge density among selected nodes.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"function uses simple greedy algorithm build candidate cliques returns largest one finds satisfies density threshold.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":null,"dir":"Reference","previous_headings":"","what":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"function runs implementation (dictated number) using inputs adj_mat alpha. example, compute_maximal_partial_clique_master(adj_mat, alpha, number = 5) executes compute_maximal_partial_clique5(adj_mat, alpha).","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"","code":"compute_maximal_partial_clique_master(adj_mat, alpha, number, time_limit = 30)"},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"adj_mat symmetric matrix values 0 1, 1's along diagonal, row- column-names, 5 50  rows/columns (inclusive) alpha single numeric (.e., length 1), value 0.5 1 (inclusive) number implementation number use time_limit number seconds implementation times ","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"list clique_idx, edge_density (implementation ) status valid (added function)","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"implementation errors (.e., crashes), output status error. implementation complete within time_limit number seconds (.e., took long), output status timed_out. valid output boolean whether provided clique_idx forms valid partial clique. method status timed_out error, method (default) valid=FALSE.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/generate_partial_clique.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Random Graph with a Partial Clique — generate_partial_clique","title":"Generate a Random Graph with a Partial Clique — generate_partial_clique","text":"Generate Random Graph Partial Clique","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/generate_partial_clique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Random Graph with a Partial Clique — generate_partial_clique","text":"","code":"generate_partial_clique(   n,   clique_fraction,   clique_edge_density,   density_rest = 0.1 )"},{"path":"https://meng-yung.github.io/UWBiost561/reference/generate_partial_clique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Random Graph with a Partial Clique — generate_partial_clique","text":"n Integer. Total number nodes graph. Must positive integer. clique_fraction Numeric 0 1. Fraction nodes include partial clique. actual number clique nodes round(n * clique_fraction). clique_edge_density Numeric 0 1. Target edge density among nodes partial clique (e.g., 1 = fully connected, 0 = edges). density_rest Numeric 0 1. Edge density rest graph outside partial clique. Defaults 0.1.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/generate_partial_clique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Random Graph with a Partial Clique — generate_partial_clique","text":"list following elements: adj_mat, n x n symmetric adjacency matrix binary entries (0 1), 1s diagonal. partial clique appropriate size density embedded. rev_order, integer vector length n indicating permutation node labels used randomize row/column order matrix.","code":""},{"path":"https://meng-yung.github.io/UWBiost561/reference/generate_partial_clique.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Random Graph with a Partial Clique — generate_partial_clique","text":"","code":"generate_partial_clique(n = 10, clique_fraction = 0.5, clique_edge_density = 0.9) #> $adj_mat #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    1    1    1    0    0    1    0    1    0     0 #>  [2,]    1    1    0    1    0    1    1    1    0     0 #>  [3,]    1    0    1    0    0    0    0    0    1     0 #>  [4,]    0    1    0    1    0    0    0    0    0     0 #>  [5,]    0    0    0    0    1    0    0    0    0     0 #>  [6,]    1    1    0    0    0    1    1    1    0     0 #>  [7,]    0    1    0    0    0    1    1    1    1     0 #>  [8,]    1    1    0    0    0    1    1    1    0     0 #>  [9,]    0    0    1    0    0    0    1    0    1     0 #> [10,]    0    0    0    0    0    0    0    0    0     1 #>  #> $rev_order #>  [1]  1  6  7  2  8  4  9  3 10  5 #>"}]
